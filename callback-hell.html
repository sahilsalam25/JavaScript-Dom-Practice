<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call-Back Hell</title>
</head>
<body>
    <h2>
        Call-Back Hell
    </h2>
    <p>Callback hell, also known as "pyramid of doom," is a situation in JavaScript programming where multiple asynchronous operations are nested within each other, resulting in code that is difficult to read, understand, and maintain. This nesting occurs when callbacks are used to handle asynchronous tasks, and those tasks are dependent on the completion of other tasks.</p>
    <script>

    </script>
</body>
</html> -->

<!-- <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Callback Hell</title>

    <style>
      * {
        padding: none;
        margin: none;
        box-sizing: border-box;
      }

      .word {
        color: #308d46;
        font-size: 4rem;
        transition: all 0.5s ease-in;
        margin: 0 5px;
        transform: translateY(3.8rem);
        opacity: 0;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 95vw;
        height: 95vh;
      }

      .container {
        overflow: hidden;
        display: flex;
        flex-direction: row;
      }

      .animate {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>

  <body>
    <div class="container">
      <h2 class="word">This is...!</h2>
      <h2 class="word">Sahil</h2>
      <h2 class="word">Salam</h2>
    </div>
    <div>
      <p>
        Callback hell, also known as "pyramid of doom," is a situation in
        JavaScript programming where multiple asynchronous operations are nested
        within each other, resulting in code that is difficult to read,
        understand, and maintain. This nesting occurs when callbacks are used to
        handle asynchronous tasks, and those tasks are dependent on the
        completion of other tasks.
      </p>
    </div>
  </body>
  <script>
    let words = document.querySelectorAll(".word");

    const animateAll = (animate) => {
      setTimeout(() => {
        animate(words[0]);
        setTimeout(() => {
          animate(words[1]);
          setTimeout(() => {
            animate(words[2]);
          }, 1000);
        }, 1000);
      }, 1000);
    };

    const animate = (word) => {
      word.classList.add("animate");
    };

    animateAll(animate);
  </script>
</html> -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Callback Hell Example</title>
  </head>
  <body>
    <div id="output"></div>

    <script>
      // Simulated asynchronous functions
      function asyncFunction1(callback) {
        setTimeout(function () {
          callback("Result 1");
        }, 1000);
      }

      function asyncFunction2(input, callback) {
        setTimeout(function () {
          callback("Result 2 processed with " + input);
        }, 1000);
      }

      function asyncFunction3(input, callback) {
        setTimeout(function () {
          callback("Result 3 processed with " + input);
        }, 1000);
      }

      // Callback hell example
      asyncFunction1(function (result1) {
        document.getElementById("output").innerText += result1 + "\n";

        asyncFunction2(result1, function (result2) {
          document.getElementById("output").innerText += result2 + "\n";

          asyncFunction3(result2, function (result3) {
            document.getElementById("output").innerText += result3 + "\n";
          });
        });
      });
    </script>
  </body>
</html>
